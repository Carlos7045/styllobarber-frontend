'use client'

import { useEffect, useRef, useCallback, useState } from 'react'
import { useRouter } from 'next/navigation'
import { supabase } from '@/lib/supabase'
import { useAuth } from './use-auth'
import { clearAuthLocalData } from '@/lib/auth-utils'

interface SessionManagerOptions {
  checkInterval?: number // Intervalo de verifica√ß√£o em ms (padr√£o: 30s)
  warningThreshold?: number // Tempo antes da expira√ß√£o para avisar (padr√£o: 5min)
  autoRefresh?: boolean // Renova√ß√£o autom√°tica de tokens (padr√£o: true)
  onSessionExpired?: () => void
  onSessionWarning?: (timeLeft: number) => void
  onTokenRefreshed?: () => void
  onSessionError?: (error: string) => void
}

interface SessionState {
  isValid: boolean
  expiresAt: number | null
  timeUntilExpiry: number | null
  isRefreshing: boolean
  lastRefresh: number | null
  warningShown: boolean
}

export function useSessionManager(options: SessionManagerOptions = {}) {
  const {
    checkInterval = 30000, // 30 segundos
    warningThreshold = 300000, // 5 minutos
    autoRefresh = true,
    onSessionExpired,
    onSessionWarning,
    onTokenRefreshed,
    onSessionError,
  } = options

  const { session, signOut, loading } = useAuth()
  const router = useRouter()
  
  const [sessionState, setSessionState] = useState<SessionState>({
    isValid: false,
    expiresAt: null,
    timeUntilExpiry: null,
    isRefreshing: false,
    lastRefresh: null,
    warningShown: false,
  })

  const intervalRef = useRef<NodeJS.Timeout | null>(null)
  const refreshTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // Fun√ß√£o para calcular tempo at√© expira√ß√£o
  const calculateTimeUntilExpiry = useCallback((expiresAt: number): number => {
    return Math.max(0, expiresAt * 1000 - Date.now())
  }, [])

  // Fun√ß√£o para verificar se a sess√£o √© v√°lida
  const isSessionValid = useCallback((session: any): boolean => {
    if (!session?.access_token || !session?.expires_at) {
      return false
    }

    const timeUntilExpiry = calculateTimeUntilExpiry(session.expires_at)
    return timeUntilExpiry > 0
  }, [calculateTimeUntilExpiry])

  // Fun√ß√£o para renovar token
  const refreshToken = useCallback(async (): Promise<boolean> => {
    try {
      console.log('üîÑ Tentando renovar token...')
      setSessionState(prev => ({ ...prev, isRefreshing: true }))

      const { data, error } = await supabase.auth.refreshSession()

      if (error) {
        console.error('‚ùå Erro ao renovar token:', error)
        onSessionError?.(error.message)
        return false
      }

      if (data.session) {
        console.log('‚úÖ Token renovado com sucesso')
        setSessionState(prev => ({
          ...prev,
          isRefreshing: false,
          lastRefresh: Date.now(),
          warningShown: false,
        }))
        onTokenRefreshed?.()
        return true
      }

      return false
    } catch (error) {
      console.error('‚ùå Erro inesperado ao renovar token:', error)
      setSessionState(prev => ({ ...prev, isRefreshing: false }))
      onSessionError?.(error instanceof Error ? error.message : 'Erro inesperado')
      return false
    }
  }, [onSessionError, onTokenRefreshed])

  // Fun√ß√£o para lidar com sess√£o expirada
  const handleSessionExpired = useCallback(async () => {
    console.log('‚ö†Ô∏è Sess√£o expirada detectada')
    
    try {
      // Tentar renovar uma √∫ltima vez
      if (autoRefresh) {
        const renewed = await refreshToken()
        if (renewed) {
          console.log('‚úÖ Sess√£o renovada ap√≥s expira√ß√£o')
          return
        }
      }

      // Se n√£o conseguiu renovar, fazer logout
      console.log('üö™ Fazendo logout por sess√£o expirada')
      
      // Limpar dados locais
      clearAuthLocalData()
      
      // Callback personalizado
      onSessionExpired?.()
      
      // Fazer logout no Supabase
      await signOut()
      
      // Redirecionar para login com par√¢metro de sess√£o expirada
      router.replace('/login?reason=session-expired')
      
    } catch (error) {
      console.error('‚ùå Erro ao lidar com sess√£o expirada:', error)
      
      // For√ßar limpeza e redirecionamento mesmo com erro
      clearAuthLocalData()
      router.replace('/login?reason=session-error')
    }
  }, [autoRefresh, refreshToken, onSessionExpired, signOut, router])

  // Fun√ß√£o para verificar estado da sess√£o
  const checkSessionState = useCallback(async () => {
    if (loading || !session) {
      setSessionState(prev => ({
        ...prev,
        isValid: false,
        expiresAt: null,
        timeUntilExpiry: null,
      }))
      return
    }

    const expiresAt = session.expires_at
    const timeUntilExpiry = expiresAt ? calculateTimeUntilExpiry(expiresAt) : null
    const isValid = isSessionValid(session)

    setSessionState(prev => ({
      ...prev,
      isValid,
      expiresAt,
      timeUntilExpiry,
    }))

    // Se a sess√£o expirou
    if (!isValid && expiresAt) {
      await handleSessionExpired()
      return
    }

    // Se est√° pr√≥ximo da expira√ß√£o e deve avisar
    if (
      isValid && 
      timeUntilExpiry !== null && 
      timeUntilExpiry <= warningThreshold && 
      !sessionState.warningShown &&
      !sessionState.isRefreshing
    ) {
      console.log(`‚ö†Ô∏è Sess√£o expira em ${Math.round(timeUntilExpiry / 1000)}s`)
      setSessionState(prev => ({ ...prev, warningShown: true }))
      onSessionWarning?.(timeUntilExpiry)

      // Se deve renovar automaticamente
      if (autoRefresh) {
        await refreshToken()
      }
    }

  }, [
    loading,
    session,
    calculateTimeUntilExpiry,
    isSessionValid,
    handleSessionExpired,
    warningThreshold,
    sessionState.warningShown,
    sessionState.isRefreshing,
    onSessionWarning,
    autoRefresh,
    refreshToken,
  ])

  // Fun√ß√£o para agendar renova√ß√£o autom√°tica
  const scheduleTokenRefresh = useCallback(() => {
    if (!session?.expires_at || !autoRefresh) return

    const expiresAt = session.expires_at * 1000
    const now = Date.now()
    const timeUntilExpiry = expiresAt - now

    // Renovar 2 minutos antes da expira√ß√£o
    const refreshTime = Math.max(0, timeUntilExpiry - 120000)

    if (refreshTimeoutRef.current) {
      clearTimeout(refreshTimeoutRef.current)
    }

    refreshTimeoutRef.current = setTimeout(async () => {
      console.log('‚è∞ Renova√ß√£o autom√°tica agendada executada')
      await refreshToken()
    }, refreshTime)

    console.log(`‚è∞ Renova√ß√£o agendada para ${Math.round(refreshTime / 1000)}s`)
  }, [session, autoRefresh, refreshToken])

  // Inicializar verifica√ß√£o peri√≥dica
  useEffect(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current)
    }

    intervalRef.current = setInterval(checkSessionState, checkInterval)
    
    // Verificar imediatamente
    checkSessionState()

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
    }
  }, [checkSessionState, checkInterval])

  // Agendar renova√ß√£o autom√°tica quando sess√£o muda
  useEffect(() => {
    scheduleTokenRefresh()

    return () => {
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current)
      }
    }
  }, [scheduleTokenRefresh])

  // Limpar timers ao desmontar
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current)
      }
    }
  }, [])

  // Fun√ß√£o para for√ßar verifica√ß√£o
  const forceCheck = useCallback(() => {
    checkSessionState()
  }, [checkSessionState])

  // Fun√ß√£o para for√ßar renova√ß√£o
  const forceRefresh = useCallback(async (): Promise<boolean> => {
    return await refreshToken()
  }, [refreshToken])

  // Fun√ß√£o para invalidar sess√£o manualmente
  const invalidateSession = useCallback(async (reason: string = 'manual') => {
    console.log(`üö™ Invalidando sess√£o: ${reason}`)
    await handleSessionExpired()
  }, [handleSessionExpired])

  return {
    // Estado da sess√£o
    sessionState,
    
    // Fun√ß√µes de controle
    forceCheck,
    forceRefresh,
    invalidateSession,
    
    // Informa√ß√µes √∫teis
    isSessionValid: sessionState.isValid,
    timeUntilExpiry: sessionState.timeUntilExpiry,
    isRefreshing: sessionState.isRefreshing,
    
    // Formatadores √∫teis
    formatTimeUntilExpiry: (ms: number | null): string => {
      if (!ms) return 'Desconhecido'
      
      const minutes = Math.floor(ms / 60000)
      const seconds = Math.floor((ms % 60000) / 1000)
      
      if (minutes > 0) {
        return `${minutes}m ${seconds}s`
      }
      return `${seconds}s`
    },
  }
}